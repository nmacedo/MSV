/*
 * FM2CFs multidirectional transformation
 *
 * Very minimal model for SPL engineering, as defined in the fm2cps.qvtr QVT-r transformation.
 *
 * Demonstration of the models generated by the FM2CFs QVT-r multidirectional transformation.
 *
 * Used as running example in
 * [1] N. Macedo, A. Cunha and H. Pacheco. Towards a framework for multi-directional model transformations. BX'14
 * 
 * author: nmm, 10/2013
 */
 module fm2cfs

sig Class1 {
  name : one String
}

sig Class2 {
  name : one String
}

sig Feature {
  name : one String
}

fact {
  all n : String |
   lone (Class1 <: name).n &&
   lone (Class2 <: name).n &&
   lone (Feature <: name).n
}

sig Mandatory in Feature {}

pred R_f [] {
  all c1 : Class1, c2 : Class2, n : String | (n = c1.name && n = c2.name) => 
    (some f : Feature | f in Mandatory && n = f.name)
}

pred R_c1 [] {
  all f : Feature, c2 : Class2, n : String | (f in Mandatory && n = f.name && n = c2.name) => 
    (some c1 : Class1 | n = c1.name)
}

pred R_c2 [] {
  all f : Feature, c1 : Class1, n : String | (f in Mandatory && n = f.name && n = c1.name) => 
    (some c2 : Class2 | n = c2.name)
}

pred R_cc [] {
  all f : Feature, n : String | (f in Mandatory && n = f.name) => 
    (some c1 : Class1, c2 : Class2 | n = c1.name && n = c2.name)
}

pred R_cf [] {
 all c1 : Class1, n : String | n = c1.name => 
    (some f : Feature, c2 : Class2 | n = c2.name && n = f.name && f in Mandatory)
}

pred R_fc [] {
 all c2 : Class2, n : String | n = c2.name => 
    (some f : Feature, c1 : Class1 | n = c1.name && n = f.name && f in Mandatory)
}

pred R_xc2 [] {
  all f : Feature, c1 : Class1 |
    (some c2 : Class2 |  pos1[c1,c2,f] )
}

pred R_xc1 [] {
  all f : Feature, c2 : Class2 |
    (some c1 : Class1 | pos2[c1,c2,f] )
}

pred R_xf [] {
  all c2 : Class2, c1 : Class1 |
    (some f : Feature | pos[c1,c2,f] )
}

pred pos [c1 : Class1, c2 : Class2, f : Feature] {
	c1.name = c2.name => f.name = c1.name && f in Mandatory
}

pred pos1 [c1 : Class1, c2 : Class2, f : Feature] {
	 f in Mandatory => f.name = c2.name
}


pred pos2 [c1 : Class1, c2 : Class2, f : Feature] {
	 f in Mandatory => c1.name = f.name
}



pred R_1 [] {
  R_c2 && R_c1 && R_f
}

pred R_2 [] {
  R_cc && R_f
}

pred R_3 [] {
  R_cc && R_fc && R_cf
}

pred R_x [] {
  R_xc1 && R_xc2 && R_xf
}


assert R_1_good {
  R_1 =>
  Class1.name&Class2.name = Mandatory.name
}

assert R_2_good {
  R_2 =>
  Class1.name&Class2.name = Mandatory.name
}

assert R_3_good {
  R_3 =>
  Class1.name&Class2.name = Mandatory.name
}

assert R_x_good {
  R_x =>
  Class1.name&Class2.name = Mandatory.name
}

check R_1_good for exactly 3 Class1, exactly 3 Class2,  exactly 4 Feature, exactly 4 String
check R_2_good for exactly 0 Class1, exactly 0 Class2,  exactly 5 Feature, exactly 10 String
check R_3_good for exactly 0 Class1, exactly 3 Class2,  exactly 4 Feature, exactly 10 String

run R_2 for exactly 0 Class1, exactly 3 Class2,  exactly 4 Feature, exactly 10 String
run R_3 for exactly 0 Class1, exactly 3 Class2,  exactly 4 Feature, exactly 10 String

run R_x for exactly 2 Class1, exactly 3 Class2,  exactly 3 Feature, exactly 3 String

check R_x_good for exactly 4 Class1, exactly 7 Class2,  exactly 5 Feature, exactly 10 String

check {R_x <=> R_2} for exactly 0 Class1, exactly 0 Class2,  exactly 1 Feature, exactly 10 String
run {R_x} for exactly 0 Class1, exactly 0 Class2,  exactly 1 Feature, exactly 10 String
run {R_2} for exactly 0 Class1, exactly 0 Class2,  exactly 1 Feature, exactly 10 String
